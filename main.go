package main

import (
	"fmt"
	"log/slog"
	"os"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoreflect"
)

func Descriptor(d protoreflect.Descriptor) []any {
	result := []any{
		slog.Any("Index", d.Index()),
		slog.Any("Syntax", d.Syntax()),
		slog.Any("Name", d.Name()),
		slog.Any("FullName", d.FullName()),
		slog.Any("IsPlaceholder", d.IsPlaceholder()),
	}
	options := d.Options()
	if options != nil {
		protoReflect := options.ProtoReflect()
		if protoReflect != nil {
			// descriptor := protoReflect.Descriptor()
			// if descriptor != nil {
			// 	result = append(result,
			// 		slog.Group("Options.ProtoReflect.Descriptor", MessageDescriptor(descriptor)...),
			// 	)
			// }
			protoReflect.Range(func(fd protoreflect.FieldDescriptor, v protoreflect.Value) bool {
				result = append(result,
					slog.Group("Options.ProtoReflect.Range", FieldDescriptor(fd)...),
				)
				return true
			})
		}
	}
	return result
}

func FieldDescriptor(fd protoreflect.FieldDescriptor) []any {
	return []any{
		slog.Group("Descriptor", Descriptor(fd)...),
		slog.Any("Number", fd.Number()),
		slog.Any("Cardinality", fd.Cardinality()),
		slog.Any("Kind", fd.Kind()),
		slog.Any("HasJSONName", fd.HasJSONName()),
		slog.Any("JSONName", fd.JSONName()),
		slog.Any("TextName", fd.TextName()),
		slog.Any("HasPresence", fd.HasPresence()),
		slog.Any("IsExtension", fd.IsExtension()),
		slog.Any("HasOptionalKeyword", fd.HasOptionalKeyword()),
		slog.Any("IsWeak", fd.IsWeak()),
		slog.Any("IsPacked", fd.IsPacked()),
		slog.Any("IsList", fd.IsList()),
		slog.Any("IsMap", fd.IsMap()),
		slog.Any("MapKey", fd.MapKey()),
		slog.Any("MapValue", fd.MapValue()),
		slog.Any("HasDefault", fd.HasDefault()),
		slog.Any("Default", fd.Default()),
		slog.Any("DefaultEnumValue", fd.DefaultEnumValue()),
		slog.Any("ContainingOneof", fd.ContainingOneof()),
		slog.Any("ContainingMessage.FullName", fd.ContainingMessage().FullName()),
		slog.Any("Enum", fd.Enum()),
	}
}

func FieldDescriptors(fds protoreflect.FieldDescriptors) []any {
	result := []any{}
	for i := 0; i < fds.Len(); i++ {
		result = append(result,
			slog.Group(fmt.Sprintf("%d", i), FieldDescriptor(fds.Get(i))...),
		)
	}
	return result
}

func MethodDescriptor(md protoreflect.MethodDescriptor) []any {
	return []any{
		slog.Group("Descriptor", Descriptor(md)...),
		slog.Any("Input", md.Input()),
		slog.Any("Output", md.Output()),
		slog.Any("IsStreamingClient", md.IsStreamingClient()),
		slog.Any("IsStreamingServer", md.IsStreamingServer()),
	}
}

func MethodDescriptors(mds protoreflect.MethodDescriptors) []any {
	result := []any{}
	for i := 0; i < mds.Len(); i++ {
		result = append(result,
			slog.Group(fmt.Sprintf("%d", i), MethodDescriptor(mds.Get(i))...),
		)
	}
	return result
}

func ServiceDescriptor(sd protoreflect.ServiceDescriptor) []any {
	return []any{
		slog.Group("Descriptor", Descriptor(sd)...),
		slog.Any("Methods", sd.Methods()),
	}
}

func ServiceDescriptors(sds protoreflect.ServiceDescriptors) []any {
	result := []any{}
	for i := 0; i < sds.Len(); i++ {
		result = append(result,
			slog.Group(fmt.Sprintf("%d", i), ServiceDescriptor(sds.Get(i))...),
		)
	}
	return result
}

func MessageDescriptor(md protoreflect.MessageDescriptor) []any {
	return []any{
		slog.Group("Descriptor", Descriptor(md)...),
		slog.Any("IsMapEntry", md.IsMapEntry()),
		slog.Group("Fields", FieldDescriptors(md.Fields())...),
	}
}

func MessageDescriptors(mds protoreflect.MessageDescriptors) []any {
	result := []any{}
	for i := 0; i < mds.Len(); i++ {
		result = append(result,
			slog.Group(fmt.Sprintf("%d", i), MessageDescriptor(mds.Get(i))...),
		)
	}
	return result
}

func generateFile(p *protogen.Plugin, file *protogen.File) {
	filename := file.GeneratedFilenamePrefix + ".go"
	slog.Info("generate file",
		slog.String("path", string(file.GoImportPath)),
		slog.String("filename", filename))

	f := p.NewGeneratedFile(filename, file.GoImportPath)
	f.P("// Code generated by protoc-gen-example. DO NOT EDIT.")
	f.P()

	f.P("package ", file.GoPackageName)
	f.P()

	for _, s := range file.Services {
		slog.Info("Service",
			slog.Group("Desc", ServiceDescriptor(s.Desc)...),
			slog.Any("GoName", s.GoName),
			slog.Any("Methods", s.Methods),
			slog.Any("Location", s.Location),
			slog.Any("Comments", s.Comments),
		)
	}

	for _, m := range file.Messages {
		logs := []any{}
		logs = append(logs, slog.Group("Desc", MessageDescriptor(m.Desc)...))
		logs = append(logs, slog.Any("GoIdent", m.GoIdent.String()))
		fields := []any{}
		for i, field := range m.Fields {
			field := field
			fields = append(fields,
				slog.Group(fmt.Sprintf("%d", i),
					slog.Group("Desc", FieldDescriptor(field.Desc)...),
					slog.Any("GoName", field.GoName),
					slog.Any("GoIdent", field.GoIdent.String()),
					slog.Any("Location", field.Location),
					slog.Any("Comments", field.Comments),
				),
			)
		}
		logs = append(logs, slog.Group("Fields", fields...))
		logs = append(logs, slog.Any("Location", m.Location))
		logs = append(logs, slog.Any("Comments", m.Comments))
		slog.Info("Message", logs...)
	}
}

func main() {
	slog.SetDefault(slog.New(
		NewIdentJSONHandlers(os.Stderr,
			&slog.HandlerOptions{
				Level: slog.LevelDebug,
			},
		),
	))

	protogen.Options{}.Run(func(p *protogen.Plugin) error {
		for _, f := range p.Files {
			if !f.Generate {
				continue
			}
			generateFile(p, f)
		}
		return nil
	})
}
